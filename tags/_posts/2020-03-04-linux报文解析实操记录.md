---
title: Linux 报文解析记录
date: 2020-03-04
categories:
- Linux
tags:
- Linux
- Linux-networking
---



## 捕获报文

如果你想解析报文，首先要做到的就是捕获到整个报文。而捕获到全部网卡接收到的报文信息，那么就要设置socket的模式。

```c
socket(AF_PACKET, SOCK_RAW, htons(ETH_P_IPV6));
```

AF_PACKET 定义在 socket.h 中 `#define AF_PACKET    PF_PACKET` 所以说实际使用中，使用AF 和 PF 都是一样的。
SOCK_RAW  定义在 socket_type.h 中, 其含义是创建原始套接字。
socket的第二个参数可以被设置为SOCK_DGRAM，主要区别是当指定SOCK_DGRAM时，获取的数据包是去掉了数据链路层的头(link-layer header)，当指定SOCK_RAW时，获取的数据包是一个完整的数据链路层数据包；

```c
#define SOCK_DGRAM SOCK_DGRAM
  SOCK_RAW = 3,            /* Raw protocol interface.  */
```

第三个参数是指定协议类型，需要注意的是需要使用htos将其转化为网络字节序。
其它数据链路层类型定义的常量参数有 ETH_P_ARP 和 ETH_P_IPV6；
指定协议(protocol)为ETH_P_XXX即告诉数据链路层我只接收该类型的帧(frame)，socket会自动过滤。如果数据链路支持混杂模式(promiscuous mode)，可以设置socket可选参数PACKET_ADD_MEMBERSHIP选项，使用packet_mreq结构体指定一个以太网接口和混杂模式行为(PACKET_MR_PROMISC)。

经过这一系列的设置我们就可以捕获到IPV6包的原始信息(包含整个数据包).

如果要获取从指定以太网接口卡上的数据包时，在　struct sockaddr_ll中指定网络接口卡，绑定(bind)数据包到该interface上。只有sll_protocol和 sll_ifindex这两个地址字段是用来bind的。 

```c
/* 定义在 if_packet.h 中 */

struct sockaddr_ll {
    unsigned short    sll_family;
    __be16        sll_protocol;
    int        sll_ifindex;
    unsigned short    sll_hatype;
    unsigned char    sll_pkttype;
    unsigned char    sll_halen;
    unsigned char    sll_addr[8];
};
```

sll_protocol : 标准以太网协议类型，按网络字节顺序。定义在中。
sll_ifindex: interface索引，0 匹配所有的网络接口卡； 
sll_hatype: ARP 硬件地址类型(hardware address type) 定义在中,常用 ARPHRD_ETHER
sll_pkttype: 包含了packet类型。
        PACK_HOST                  包地址为本地主机地址。
        PACK_BROADCAST    物理层广播包。
        PACK_MULTICAST      发送到物理层多播地址的包。
        PACK_OTHERHOST    发往其它在混杂模式下被设备捕获的主机的包。
        PACK_OUTGOING        本地回环包；
sll_addr 和 ssl_halen 包含了物理层地址和其长度；

当发送数据包时，指定 sll_family, sll_addr, sll_halen, sll_ifindex, sll_protocol 就足够了。其它字段设置为0； sll_hatype和 sll_pkttype是在接收数据包时使用的； 如果要bind, 只需要使用 sll_protocol和 sll_ifindex；

**绑定端口：**

`setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE, ifname, strlen(ifname)))`

**指定该数据包不需要路由：**

`int set_donot_route = 1;`
`setsockopt(sockfd, SOL_SOCKET, SO_DONTROUTE, &set_donot_route, sizeof(set_donot_route)))`

**指定跳数：**

 must set to 255 or the LAN/WAN host will not accept this RA packet
`unsigned hops = 255;`
`setsockopt(port->icmpv6_sock, SOL_IPV6, IPV6_MULTICAST_HOPS, &hops, sizeof(hops)))`

## 解析报文

解析报文可以通过将报文数据移动指针位置之后转换成对应格式的结构

**以太网头报文：**

```c
/* ethernet.h */

/* 10Mb/s ethernet header */
struct ether_header
{
  uint8_t  ether_dhost[ETH_ALEN];    /* destination eth addr    */
  uint8_t  ether_shost[ETH_ALEN];    /* source ether addr    */
  uint16_t ether_type;                /* packet type ID field    */
} __attribute__ ((__packed__));
```

**ipv6/ipv4 报头：**

```c
/*netinet/ip6.h*/

struct ip6_hdr
  {
    union
      {
    struct ip6_hdrctl
      {
        uint32_t ip6_un1_flow;   /* 4 bits version, 8 bits TC,
                    20 bits flow-ID */
        uint16_t ip6_un1_plen;   /* payload length */
        uint8_t  ip6_un1_nxt;    /* next header */
        uint8_t  ip6_un1_hlim;   /* hop limit */
      } ip6_un1;
    uint8_t ip6_un2_vfc;       /* 4 bits version, top 4 bits tclass */
      } ip6_ctlun;
    struct in6_addr ip6_src;      /* source address */
    struct in6_addr ip6_dst;      /* destination address */
  };

#define ip6_vfc   ip6_ctlun.ip6_un2_vfc
#define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim
```

**icmpv6 报头：**

```c
/*netinet/icmp6.h*/

struct icmp6_hdr
  {
    uint8_t     icmp6_type;   /* type field */
    uint8_t     icmp6_code;   /* code field */
    uint16_t    icmp6_cksum;  /* checksum field */
    union
      {
    uint32_t  icmp6_un_data32[1]; /* type-specific field */
    uint16_t  icmp6_un_data16[2]; /* type-specific field */
    uint8_t   icmp6_un_data8[4];  /* type-specific field */
      } icmp6_dataun;
  };

#define icmp6_data32    icmp6_dataun.icmp6_un_data32
#define icmp6_data16    icmp6_dataun.icmp6_un_data16
#define icmp6_data8     icmp6_dataun.icmp6_un_data8
#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */
#define icmp6_mtu       icmp6_data32[0]  /* packet too big */
#define icmp6_id        icmp6_data16[0]  /* echo request/reply */
#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */
#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group membership */
```

## 代码实例

```c
struct icmp6* parse_icmp6(void *pkt, size_t len)
{
    size_t tmp;
    size_t hdrlen;
    size_t offset;
    static uint8_t buffer[1520];
    struct ether_header *ethdr = eth_header(pkt, &offset);
    struct ip6_hdr *ip6hdr = ip6_header(ethdr, &offset);
    struct icmp6_hdr * icmp6hdr = icmp6_header(ip6hdr, &offset);

    switch (icmp6hdr->icmp6_type)
    {
        case ND_ROUTER_ADVERT:
            hdrlen = sizeof(struct nd_router_advert);
            break;
        case ND_ROUTER_SOLICIT:
            hdrlen = sizeof(struct nd_router_solicit);
            break;
        case ND_NEIGHBOR_ADVERT:
            hdrlen = sizeof(struct nd_neighbor_advert);
            break;
        case ND_NEIGHBOR_SOLICIT:
            hdrlen = sizeof(struct nd_neighbor_solicit);
            break;
        default:
            return NULL;
    } 

    offset += hdrlen;
    tmp = offset;
    union icmp6_opt *opt = (union icmp6_opt*)(pkt + offset);
    size_t count = 0;
    while(offset < len && opt->comm.nd_opt_type && opt->comm.nd_opt_len){
        count += 1;
        opt = (union icmp6_opt*)((void*)opt + opt->comm.nd_opt_len * 8);
        offset += opt->comm.nd_opt_len * 8;
    }

    struct icmp6 *icmp6 = (struct icmp6*)buffer;

    icmp6->opt_cnt = count;
    if( !icmp6 ){
        handle_error("can not creat icmp6 obhect");
    }

    offset = tmp;
    memcpy(&icmp6->comm, icmp6hdr, hdrlen);
    for(size_t i=0; i<count; i++){
        opt = (union icmp6_opt*)(pkt + offset);
        memcpy(&icmp6->opt[i], opt, opt->comm.nd_opt_len * 8);
        offset += opt->comm.nd_opt_len;
    }
    memcpy(&icmp6->ethaddr, ethdr, sizeof(*ethdr));
    memcpy(&icmp6->ip6hdr, ip6hdr, sizeof(*ip6hdr));

    return icmp6;
}


static struct ether_header* eth_header(void *pkt, size_t *offset)
{
    *offset = 0;
    return (struct ether_header*)pkt;
}

static struct ip6_hdr* ip6_header(void *pkt, size_t *offset)
{
    *offset += sizeof(struct ether_header);
    return (struct ip6_hdr*)(pkt + (*offset));
}

struct icmp6_hdr* icmp6_header(void *pkt, size_t *offset)
{
    *offset += sizeof(struct ip6_hdr);
    struct ip6_hdr *hdr = (struct ip6_hdr*)pkt;

    if(hdr->ip6_nxt == IPPROTO_ICMPV6)
        return (struct icmp6_hdr*)(hdr+1);

    /* if it have extension header */
    struct ip6_ext *ehdr = (struct ip6_ext*)(hdr + 1);
    *offset += (ehdr->ip6e_len + sizeof(struct ip6_ext));
    while(ehdr->ip6e_nxt != IPPROTO_ICMPV6){
        ehdr = (struct ip6_ext*)((void *)ehdr + ehdr->ip6e_len + sizeof(struct ip6_ext));
        *offset += (ehdr->ip6e_len + sizeof(struct ip6_ext));
    }
    return (struct icmp6_hdr*)((void *)ehdr + ehdr->ip6e_len + sizeof(struct ip6_ext));
}
```